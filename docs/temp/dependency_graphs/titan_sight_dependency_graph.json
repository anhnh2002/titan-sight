{
  "src.app.ping": {
    "id": "src.app.ping",
    "name": "ping",
    "component_type": "function",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/app.py",
    "relative_path": "src/app.py",
    "depends_on": [],
    "source_code": "def ping(req: Request):\n    return {\"status\": \"Healthy\"}",
    "start_line": 37,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ping",
    "component_id": "src.app.ping"
  },
  "src.app.search_v1": {
    "id": "src.app.search_v1",
    "name": "search_v1",
    "component_type": "function",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/app.py",
    "relative_path": "src/app.py",
    "depends_on": [],
    "source_code": "async def search_v1(\n    query: str,\n    provider: Literal[\"searxng\", \"google\", \"duckduckgo\"] = \"duckduckgo\",\n    max_num_result: int = 3,\n    enable_cache: bool = True,\n    newest_first: bool = False,\n    sumup_page_timeout: int = 15,\n):\n    \n    start_time = time.time()\n\n    # Get the provider\n    search_provider = PROVIDERS[provider]\n\n    # Search\n    if enable_cache:\n        result = await search_provider.search_in_cache(query, max_num_result, newest_first=newest_first, sumup_page_timeout=sumup_page_timeout)\n    else:\n        result = await search_provider.search(query, max_num_result, newest_first=newest_first, sumup_page_timeout=sumup_page_timeout)\n\n    logger.info(f\"Search for '{query}' returned {len(result.results)} results in {time.time() - start_time:.2f} seconds\")\n    \n    return result",
    "start_line": 42,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "query",
      "provider",
      "max_num_result",
      "enable_cache",
      "newest_first",
      "sumup_page_timeout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function search_v1",
    "component_id": "src.app.search_v1"
  },
  "src.clients.cache_clients.ShortTermCacheClient": {
    "id": "src.clients.cache_clients.ShortTermCacheClient",
    "name": "ShortTermCacheClient",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/clients/cache_clients.py",
    "relative_path": "src/clients/cache_clients.py",
    "depends_on": [
      "src.schemas.SearchResponse"
    ],
    "source_code": "class ShortTermCacheClient:\n    \"\"\"\n    A Redis-based cache client for short-term storage of search results with vector similarity search capabilities.\n    This class implements a caching mechanism using Redis as the backend storage, specifically designed\n    for storing and retrieving search results based on vector similarity searches. It utilizes Redis JSON\n    and RediSearch for efficient storage and querying of vector embeddings.\n    Attributes:\n        client (redis.Redis): Redis client instance\n        expire_time (int): Time in seconds after which cache entries expire\n        sim_threshold (float): Similarity threshold for vector matching\n        index_name (str): Name of the Redis search index\n    Parameters:\n        redis_url (str): URL for connecting to Redis instance\n        expire_time (int): Cache expiration time in seconds\n        sim_threshold (float): Threshold for vector similarity matching\n        embedding_dim (int): Dimension of the vector embeddings\n    \"\"\"\n\n    def __init__(\n        self,\n        redis_url: str,\n        expire_time: int,\n        sim_threshold: float,\n        embedding_client: EmbeddingClient,\n        embedding_dim: int,\n    ):\n        self.client = redis.Redis.from_url(redis_url, decode_responses=True)\n\n        self.expire_time = expire_time\n        self.sim_threshold = sim_threshold\n\n        self.embedding_client = embedding_client\n        self.embedding_dim = embedding_dim\n\n        self.index_name: str=\"idx:search_vss\"\n        self._create_index()\n\n\n    def _create_index(self):\n\n        schema = (\n            VectorField(\n                \"$.query_embedding\",\n                \"FLAT\",\n                {\n                    \"TYPE\": \"FLOAT32\",\n                    \"DIM\": self.embedding_dim,\n                    \"DISTANCE_METRIC\": \"COSINE\",\n                },\n                as_name=\"vector\",\n            )\n        )\n\n        definition = IndexDefinition(prefix=[\"search:\"], index_type=IndexType.JSON)\n\n        try:\n            status = self.client.ft(self.index_name).create_index(fields=schema, definition=definition)\n            logger.info(f\"Index created: {status}\")\n        except Exception as e:\n            logger.error(f\"Error creating index: {e}\")\n    \n        \n\n    async def set(\n        self,\n        obj: SearchResponse,\n    ):\n        \n        # validate the object\n        obj = obj.model_dump()\n\n        # get the embedding for the object\n        obj[\"query_embedding\"] = await self.embedding_client.get_embedding(obj[\"query\"])\n\n        # generate a unique key for the object, format \"seach:<id>\"\n        id = str(hash(str(obj)))\n        key = f\"search:{id}\"\n\n        # set the object in the cache if it doesn't already exist\n        set_ojb = self.client.json().set(key, \"$\", obj, nx=True)\n\n        # set the expiration time\n        set_ex = self.client.expire(key, self.expire_time)\n\n        return set_ojb, set_ex\n    \n    async def get(self, query: str) -> SearchResponse:\n        \n        # get the embedding for the query\n        query_embedding = await self.embedding_client.get_embedding(query)\n\n\n        # create a query to search for similar embeddings\n        query = (\n            Query('(*)=>[KNN 1 @vector $query_vector AS vector_score]')\n            .sort_by('vector_score')\n            .return_fields('vector_score', 'id')\n            .dialect(2)\n        )\n\n        # search for similar embeddings\n        docs = self.client.ft(self.index_name).search(\n            query,\n            {\n                \"query_vector\": np.array(query_embedding, dtype=np.float32).tobytes()\n            }\n        ).docs\n\n        if not docs:\n            return None\n        \n        # get the first document\n        doc = docs[0]\n\n        # return null if the similarity score is below the threshold\n        if (1 - float(doc.vector_score)) < self.sim_threshold:\n            return None\n\n        # get the object from the cache\n        obj = self.client.json().get(doc.id)\n\n        # log the query which was found\n        logger.info(f\"Found similar query: {query}\")\n\n        return SearchResponse(**obj)",
    "start_line": 18,
    "end_line": 142,
    "has_docstring": true,
    "docstring": "A Redis-based cache client for short-term storage of search results with vector similarity search capabilities.\nThis class implements a caching mechanism using Redis as the backend storage, specifically designed\nfor storing and retrieving search results based on vector similarity searches. It utilizes Redis JSON\nand RediSearch for efficient storage and querying of vector embeddings.\nAttributes:\n    client (redis.Redis): Redis client instance\n    expire_time (int): Time in seconds after which cache entries expire\n    sim_threshold (float): Similarity threshold for vector matching\n    index_name (str): Name of the Redis search index\nParameters:\n    redis_url (str): URL for connecting to Redis instance\n    expire_time (int): Cache expiration time in seconds\n    sim_threshold (float): Threshold for vector similarity matching\n    embedding_dim (int): Dimension of the vector embeddings",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ShortTermCacheClient",
    "component_id": "src.clients.cache_clients.ShortTermCacheClient"
  },
  "src.clients.cache_clients.LongTermCacheClient": {
    "id": "src.clients.cache_clients.LongTermCacheClient",
    "name": "LongTermCacheClient",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/clients/cache_clients.py",
    "relative_path": "src/clients/cache_clients.py",
    "depends_on": [],
    "source_code": "class LongTermCacheClient:\n    \"\"\"\n    A cache client for long-term storage using MongoDB.\n    This class provides caching functionality using MongoDB as the backend storage system.\n    It stores search results with their associated URLs for long-term persistence.\n    Attributes:\n        collection: MongoDB collection object for storing cache entries\n    Args:\n        mongo_url (str): MongoDB connection URL\n        db_name (str): Name of the MongoDB database to use\n        collection_name (str): Name of the collection to store cache entries\n    Methods:\n        set(search_response): Stores search results in the cache\n        get(url): Retrieves cached details for a given URL\n    Raises:\n        errors.ConnectionFailure: If connection to MongoDB fails\n    \"\"\"\n\n\n    def __init__(\n        self,\n        mongo_url: str,\n        db_name: str,\n        collection_name: str,\n    ):\n        try:\n            mongo_client = MongoClient(mongo_url)\n        except errors.ConnectionFailure as error:\n            logger.info(f\"Error: {error}\")\n            raise error\n        db = mongo_client[db_name]\n\n        self.collection = db[collection_name]\n\n        # create an index on the URL field if it doesn't exist\n        if \"url_1\" not in self.collection.index_information():\n            self.collection.create_index(\"url\", unique=True)\n\n\n    async def set(self, search_response: SearchResponse):\n\n        for result in search_response.results:\n\n            if result.details:\n                self.collection.update_one(\n                    {\"url\": result.url},\n                    {\"$set\": {\"url\": result.url, \"details\": result.details}},\n                    upsert=True\n                )\n        \n\n\n    async def get(self, url: str) -> str:\n        # get the object from the collection\n        doc = self.collection.find_one({\"url\": url})\n\n        if not doc:\n            return None\n        \n        # log the url which was found\n        logger.info(f\"Found details for URL: {url}\")\n\n        return doc[\"details\"]",
    "start_line": 146,
    "end_line": 208,
    "has_docstring": true,
    "docstring": "A cache client for long-term storage using MongoDB.\nThis class provides caching functionality using MongoDB as the backend storage system.\nIt stores search results with their associated URLs for long-term persistence.\nAttributes:\n    collection: MongoDB collection object for storing cache entries\nArgs:\n    mongo_url (str): MongoDB connection URL\n    db_name (str): Name of the MongoDB database to use\n    collection_name (str): Name of the collection to store cache entries\nMethods:\n    set(search_response): Stores search results in the cache\n    get(url): Retrieves cached details for a given URL\nRaises:\n    errors.ConnectionFailure: If connection to MongoDB fails",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class LongTermCacheClient",
    "component_id": "src.clients.cache_clients.LongTermCacheClient"
  },
  "src.clients.embedding_clients.EmbeddingClient": {
    "id": "src.clients.embedding_clients.EmbeddingClient",
    "name": "EmbeddingClient",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/clients/embedding_clients.py",
    "relative_path": "src/clients/embedding_clients.py",
    "depends_on": [],
    "source_code": "class EmbeddingClient:\n    def __init__(\n        self,\n        base_url: str,\n        api_key: str,\n        embedding_model_name: str,\n    ):\n        self.client = AsyncOpenAI(\n            base_url=base_url,\n            api_key=api_key\n        )\n\n        self.embedding_model_name = embedding_model_name\n\n    async def get_embedding(self, text: str) -> List[float]:\n        response = await self.client.embeddings.create(\n            model=self.embedding_model_name,\n            input=text,\n        )\n\n        return response.data[0].embedding",
    "start_line": 5,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class EmbeddingClient",
    "component_id": "src.clients.embedding_clients.EmbeddingClient"
  },
  "src.clients.llm_clients.LLMClient": {
    "id": "src.clients.llm_clients.LLMClient",
    "name": "LLMClient",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/clients/llm_clients.py",
    "relative_path": "src/clients/llm_clients.py",
    "depends_on": [],
    "source_code": "class LLMClient:\n    def __init__(\n        self,\n        base_url: str,\n        api_key: str,\n        model_name: str,\n        base_model_name: str,\n        hf_token: Optional[str]=None,\n    ):\n        self.client = AsyncOpenAI(\n            base_url=base_url,\n            api_key=api_key,\n        )\n\n        self.model_name = model_name\n\n        try:\n            # Use the tokenizer from tiktoken if available\n            self.tokenizer = tiktoken.encoding_for_model(base_model_name)\n        except:\n            # Use the Hugging Face tokenizer\n            self.tokenizer = AutoTokenizer.from_pretrained(base_model_name, token=hf_token)\n\n\n    async def count_tokens(self, text: str) -> int:\n        tokenized: List[int] = self.tokenizer.encode(text)\n        return len(tokenized)\n\n\n    async def complettion(self, prompt: str) -> str:\n\n        completion = await self.client.chat.completions.create(\n            model=self.model_name,\n            messages=[\n                {\"role\": \"user\", \"content\": prompt},\n            ],\n            top_p=0.5,\n            max_tokens=MAX_ANSWER_TOKEN_PER_PAGE,\n        )\n\n        return completion.choices[0].message.content.strip()\n    \n\n    async def summarize_page(self, query: str, search_result: SearchResult) -> str:\n\n        title = search_result.title\n        url = search_result.url\n        summary = search_result.content\n        details = search_result.details\n\n        # truncate MAX_PAGE_DETAILS_LENGTH tokens from the details\n        if details:\n\n            truncated = \"\"\n            current_num_tokens = 0\n\n            for line in details.split(\"\\n\"):\n\n                line_num_tokens = await self.count_tokens(line)\n\n                if current_num_tokens + line_num_tokens > MAX_PAGE_DETAILS_LENGTH:\n                    break\n\n                truncated += line + \"\\n\"\n                current_num_tokens += line_num_tokens\n\n            details = truncated\n        \n        prompt = CONCISE_ANSWER_PROMPT.format(\n            title=title,\n            url=url,\n            summary=summary,\n            details=details,\n            query=query,\n        )\n\n        return await self.complettion(prompt)",
    "start_line": 11,
    "end_line": 87,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class LLMClient",
    "component_id": "src.clients.llm_clients.LLMClient"
  },
  "src.logs.setup_logging": {
    "id": "src.logs.setup_logging",
    "name": "setup_logging",
    "component_type": "function",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/logs.py",
    "relative_path": "src/logs.py",
    "depends_on": [],
    "source_code": "def setup_logging():\n    logging.basicConfig(level=logging.DEBUG)\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)",
    "start_line": 8,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setup_logging",
    "component_id": "src.logs.setup_logging"
  },
  "src.logs.get_logger": {
    "id": "src.logs.get_logger",
    "name": "get_logger",
    "component_type": "function",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/logs.py",
    "relative_path": "src/logs.py",
    "depends_on": [],
    "source_code": "def get_logger(name: str, file: Union[str, Path]=None, stdout=True, level=\"info\"):\n    handlers = []\n    FORMAT = \"%(asctime)s\\t%(name)s\\t%(levelname)s\\t%(message)s\"\n    level = logging.getLevelName(level.upper())\n\n    if stdout:\n        formatter = ColoredFormatter(FORMAT)\n        stdout_handler = StreamHandler()\n        stdout_handler.setLevel(level)\n        stdout_handler.setFormatter(formatter)\n        handlers.append(stdout_handler)\n\n    if file:\n        if isinstance(file, str):\n            file = Path(file)\n        file.parent.mkdir(parents=True, exist_ok=True)\n        formatter = logging.Formatter(FORMAT)\n        file_handler = logging.FileHandler(file, mode=\"a\", encoding=\"utf-8\")\n        file_handler.setLevel(logging.DEBUG)\n        file_handler.setFormatter(formatter)\n        handlers.append(file_handler)\n    \n    logger = logging.getLogger(name)\n    logger.setLevel(level)  # Add this line\n    for handler in handlers:\n        logger.addHandler(handler)\n    return logger",
    "start_line": 14,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "file",
      "stdout",
      "level"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_logger",
    "component_id": "src.logs.get_logger"
  },
  "src.schemas.SearchResult": {
    "id": "src.schemas.SearchResult",
    "name": "SearchResult",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/schemas.py",
    "relative_path": "src/schemas.py",
    "depends_on": [],
    "source_code": "class SearchResult(BaseModel):\n    title: str\n    url: str\n    content: str\n    details: Optional[str] = None\n    answer: Optional[str] = None\n    \n\n    def __str__(self):\n        return f\"Title: {self.title}\\nURL: {self.url}\\n Summary: {self.content}\"",
    "start_line": 8,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class SearchResult",
    "component_id": "src.schemas.SearchResult"
  },
  "src.schemas.SearchResponse": {
    "id": "src.schemas.SearchResponse",
    "name": "SearchResponse",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/schemas.py",
    "relative_path": "src/schemas.py",
    "depends_on": [],
    "source_code": "class SearchResponse(BaseModel):\n    query: str\n    results: List[SearchResult] = Field(default_factory=list)",
    "start_line": 20,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "BaseModel"
    ],
    "class_name": null,
    "display_name": "class SearchResponse",
    "component_id": "src.schemas.SearchResponse"
  },
  "src.search.providers.base.SearchProvider": {
    "id": "src.search.providers.base.SearchProvider",
    "name": "SearchProvider",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/search/providers/base.py",
    "relative_path": "src/search/providers/base.py",
    "depends_on": [],
    "source_code": "class SearchProvider(ABC):\n    @abstractmethod\n    async def search(self, query: str, max_num_result: int) -> SearchResponse:\n        raise NotImplementedError\n    \n    async def search_without_cache(self, query: str, max_num_result: int, sumup_page_timeout: int) -> SearchResponse:\n        response = await self.search(query, max_num_result)\n        return response\n\n    async def search_in_cache(self, query: str, max_num_result: int, newest_first: bool, sumup_page_timeout: int) -> SearchResponse:\n        cached_response = await short_term_cache_client.get(query)\n        if cached_response:\n            return cached_response\n\n        response = await self.search(query, max_num_result, newest_first=newest_first, sumup_page_timeout=sumup_page_timeout)\n\n        asyncio.create_task(short_term_cache_client.set(response))\n        asyncio.create_task(long_term_cache_client.set(response))\n\n        return response\n\n    async def fetch_details_and_generate_consise_answer(self, query: str, results_without_details: List[SearchResult], sumup_page_timeout: int) -> List[SearchResult]:\n        async def fetch_details_for_result(result: SearchResult):\n            try:\n                start_time = time.time()\n                await asyncio.sleep(0.1)\n\n                # Create tasks for both cache lookup and URL fetching\n                cached_details = await asyncio.wait_for(\n                    long_term_cache_client.get(result.url),\n                    timeout=5  # 5 seconds timeout for cache lookup\n                )\n\n                if cached_details:\n                    result.details = cached_details\n                else:\n                    # Fetch and extract with timeout\n                    html = await asyncio.wait_for(\n                        asyncio.get_event_loop().run_in_executor(\n                            None, lambda: fetch_url(result.url, config=tralifatura_config)\n                        ),\n                        timeout=10  # 10 seconds timeout for fetching\n                    )\n                    \n                    details = await asyncio.wait_for(\n                        asyncio.get_event_loop().run_in_executor(\n                            None, lambda: extract(html)\n                        ),\n                        timeout=5  # 5 seconds timeout for extraction\n                    )\n                    result.details = details\n\n                logger.info(f\"Fetched details for {result.url} in {time.time() - start_time:.2f} seconds\")\n                start_time = time.time()\n\n                await asyncio.sleep(0.1)\n\n                # Generate concise answer with timeout\n                result.answer = await asyncio.wait_for(\n                    llm_client.summarize_page(query, result),\n                    timeout=sumup_page_timeout  # sumup_page_timeout seconds timeout for LLM\n                )\n\n                logger.info(f\"Generated concise answer for {result.url} in {time.time() - start_time:.2f} seconds\")\n                return True\n\n            except asyncio.TimeoutError:\n                logger.warning(f\"Timeout while processing {result.url}\")\n                return False\n            except Exception as e:\n                logger.error(f\"Error fetching details for {result.url}: {e}\")\n                return False\n\n        # Create tasks with gather and return_exceptions=True to handle failures\n        tasks = [fetch_details_for_result(result) for result in results_without_details]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        # Filter out failed results\n        successful_results = [\n            result for result, success in zip(results_without_details, results)\n            if success and not isinstance(success, Exception)\n        ]\n\n        logger.info(f\"Successfully processed {len(successful_results)} out of {len(results_without_details)} results\")\n        return successful_results",
    "start_line": 11,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ABC"
    ],
    "class_name": null,
    "display_name": "class SearchProvider",
    "component_id": "src.search.providers.base.SearchProvider"
  },
  "src.search.providers.duckduckgo.DuckDuckGoSearchProvider": {
    "id": "src.search.providers.duckduckgo.DuckDuckGoSearchProvider",
    "name": "DuckDuckGoSearchProvider",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/search/providers/duckduckgo.py",
    "relative_path": "src/search/providers/duckduckgo.py",
    "depends_on": [
      "src.schemas.SearchResult",
      "src.schemas.SearchResponse"
    ],
    "source_code": "class DuckDuckGoSearchProvider(SearchProvider):\n    def __init__(self, **kwargs):\n        self.ddgs = DDGS()\n    \n    async def search(self, query: str, max_num_result: int) -> SearchResponse:\n\n        start_time = time.time()\n\n        # Get link results\n        link_results = await self.get_link_results(query, num_results=max_num_result)\n\n        logger.info(f\"Search links for '{query}' returned {len(link_results)} links in {time.time() - start_time:.2f} seconds\")\n\n        # Fetch details for each result\n        if link_results:\n            link_results = await self.fetch_details_and_generate_consise_answer(query, link_results)\n\n        return SearchResponse(query=query, results=link_results)\n\n    async def get_link_results(\n        self, query: str, num_results: int\n    ) -> list[SearchResult]:\n        \n        results = await asyncio.get_event_loop().run_in_executor(\n            None, lambda: self.ddgs.text(query, max_results=num_results)\n        )\n\n        return [\n            SearchResult(\n                title=result[\"title\"],\n                url=result[\"href\"],\n                content=result[\"body\"],\n            )\n            for result in results\n        ]",
    "start_line": 13,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SearchProvider"
    ],
    "class_name": null,
    "display_name": "class DuckDuckGoSearchProvider",
    "component_id": "src.search.providers.duckduckgo.DuckDuckGoSearchProvider"
  },
  "src.search.providers.google.GoogleSearchProvider": {
    "id": "src.search.providers.google.GoogleSearchProvider",
    "name": "GoogleSearchProvider",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/search/providers/google.py",
    "relative_path": "src/search/providers/google.py",
    "depends_on": [
      "src.schemas.SearchResult",
      "src.schemas.SearchResponse"
    ],
    "source_code": "class GoogleSearchProvider(SearchProvider):\n    def __init__(self, api_key: str, search_engine_id: str):\n        self.api_key = api_key\n        self.search_engine_id = search_engine_id\n    \n    async def search(self, query: str, max_num_result: int, newest_first: bool, sumup_page_timeout: int) -> SearchResponse:\n\n        start_time = time.time()\n\n        # Get link results\n        async with httpx.AsyncClient() as client:\n            link_results = await self.get_link_results(client, query, num_results=max_num_result, newest_first=newest_first)\n\n        logger.info(f\"Search links for '{query}' returned {len(link_results)} links in {time.time() - start_time:.2f} seconds\")\n\n        # Fetch details for each result\n        if link_results:\n            link_results = await self.fetch_details_and_generate_consise_answer(query, link_results, sumup_page_timeout)\n\n        return SearchResponse(query=query, results=link_results)\n\n    async def get_link_results(\n        self, client:httpx.AsyncClient, query: str, num_results: int, newest_first: bool = False\n    ) -> list[SearchResult]:\n        \n        base_url = \"https://www.googleapis.com/customsearch/v1\"\n        params = {\n            'key': self.api_key,\n            'cx': self.search_engine_id,\n            'q': query,\n        }\n        \n        if newest_first:\n            params['sort'] = 'date'\n            params['dateRestrict'] = 'y1'\n        \n        url = f\"{base_url}?{urllib.parse.urlencode(params)}\"\n\n        response = await client.get(url)\n        if response.status_code == 200:\n            data = response.json().get(\"items\", [])\n        else:\n            print(f\"Error: {response.status_code}\")\n            data = []\n\n        return [\n            SearchResult(\n                title=result[\"title\"],\n                url=result[\"link\"],\n                content=result[\"snippet\"],\n            )\n            for result in data[:num_results]\n        ]",
    "start_line": 14,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SearchProvider"
    ],
    "class_name": null,
    "display_name": "class GoogleSearchProvider",
    "component_id": "src.search.providers.google.GoogleSearchProvider"
  },
  "src.search.providers.searxng.SearxngSearchProvider": {
    "id": "src.search.providers.searxng.SearxngSearchProvider",
    "name": "SearxngSearchProvider",
    "component_type": "class",
    "file_path": "/Users/anhnh/Documents/code/titan-sight/src/search/providers/searxng.py",
    "relative_path": "src/search/providers/searxng.py",
    "depends_on": [
      "src.schemas.SearchResult",
      "src.schemas.SearchResponse"
    ],
    "source_code": "class SearxngSearchProvider(SearchProvider):\n    def __init__(self, host: str):\n        self.host = host\n    \n    async def search(self, query: str, max_num_result: int) -> SearchResponse:\n\n        start_time = time.time()\n\n        # Get link results\n        async with httpx.AsyncClient() as client:\n            link_results = await self.get_link_results(client, query, num_results=max_num_result)\n\n        logger.info(f\"Search links for '{query}' returned {len(link_results)} links in {time.time() - start_time:.2f} seconds\")\n\n        # Fetch details for each result\n        if link_results:\n            link_results = await self.fetch_details_and_generate_consise_answer(query, link_results)\n\n        return SearchResponse(query=query, results=link_results)\n\n    async def get_link_results(\n        self, client: httpx.AsyncClient, query: str, num_results: int\n    ) -> list[SearchResult]:\n        response = await client.get(\n            f\"{self.host}/search\",\n            params={\"q\": query, \"format\": \"json\"},\n        )\n        results = response.json()\n\n        return [\n            SearchResult(\n                title=result[\"title\"],\n                url=result[\"url\"],\n                content=result[\"content\"],\n            )\n            for result in results[\"results\"][:num_results]\n        ]\n\n    async def get_image_results(\n        self, client: httpx.AsyncClient, query: str, num_results: int = 4\n    ) -> list[str]:\n        response = await client.get(\n            f\"{self.host}/search\",\n            params={\"q\": query, \"format\": \"json\", \"categories\": \"images\"},\n        )\n        results = response.json()\n        return [result[\"img_src\"] for result in results[\"results\"][:num_results]]",
    "start_line": 12,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "SearchProvider"
    ],
    "class_name": null,
    "display_name": "class SearxngSearchProvider",
    "component_id": "src.search.providers.searxng.SearxngSearchProvider"
  }
}